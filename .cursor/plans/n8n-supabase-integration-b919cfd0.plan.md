<!-- b919cfd0-0fe1-4ede-acc7-ffafe284d10f f19714bf-e319-42f2-a468-4742aa91b9ae -->
# План: MD инструкция для n8n workflow (24 шага)

## Цель

Создать детальную MD инструкцию `funel_new/n8n/workflow-24-steps.md` с пошаговым описанием всех 24 нод n8n workflow от получения webhook из React до отправки результата обратно в React. Промпты для OpenAI должны анализировать 12 цветотипов согласно логике React приложения.

## Структура workflow (24 шага)

### Шаг 1-3: Получение и парсинг данных

1. **Webhook** - Прием данных из React (multipart/form-data с изображениями)
2. **Code - Парсинг данных** - Извлечение метаданных, UTM параметров, сохранение binary данных
3. **Merge** - Объединение данных для дальнейшей обработки

### Шаг 4-7: Работа с пользователем

4. **HTTP Request - Поиск пользователя** - GET запрос в Supabase по `tg_user_id`
5. **Merge** - Объединение результата поиска с исходными данными
6. **Code - Проверка результата поиска** - Определение, нужно ли создавать пользователя
7. **IF - should_create_user** - Условное ветвление

### Шаг 8-9: Создание пользователя (если нужно)

8. **HTTP Request - Создание пользователя** - POST запрос в Supabase
9. **Code - Объединение результатов пользователя** - Извлечение `user_id` (UUID)

### Шаг 10-13: Проверка лимитов

10. **HTTP Request - Подсчет сессий** - GET запрос для подсчета существующих сессий
11. **Code - Проверка лимита** - Сравнение с максимальным количеством бесплатных запросов (5)
12. **IF - limit_exceeded** - Проверка, превышен ли лимит
13. **HTTP Request - Проверка существования сессии** - Проверка, существует ли сессия с таким `session_id`

### Шаг 14-17: Загрузка изображений

14. **HTTP Request - Загрузка selfie** - PUT запрос в Supabase Storage (bucket `foto_client`)
15. **Code - Формирование selfie_url** - Создание публичного URL для selfie
16. **HTTP Request - Загрузка fullbody** - PUT запрос в Supabase Storage
17. **Code - Формирование fullbody_url** - Создание публичного URL для fullbody

### Шаг 18-22: Создание/обновление сессии

18. **Code - Объединение URL** - Объединение `selfie_url` и `fullbody_url` с данными пользователя
19. **Merge** - Объединение данных для создания сессии (user_id + URLs)
20. **Supabase - Попытка обновления сессии** - Update операция по `session_id`
21. **Code - Проверка результата обновления** - Определение, была ли сессия обновлена или нужно создать
22. **IF - should_create_session** - Условное ветвление

### Шаг 23-24: Создание сессии (если нужно)

23. **Code - Подготовка body для создания сессии** - Формирование данных для INSERT
24. **Supabase - Создание сессии** - Insert операция в таблицу `sessions`

### Шаг 25-30: Анализ изображений

25. **Code - Объединение данных для анализа** - Подготовка данных с `session_db_id` и URLs
26. **Merge** - Объединение данных с binary изображений для анализа
27. **OpenAI - Анализ selfie** - Анализ selfie изображения с промптом для 12 цветотипов
28. **Code - Парсинг результатов selfie** - Извлечение и структурирование результатов
29. **OpenAI - Анализ fullbody** - Анализ fullbody изображения с промптом для 12 цветотипов
30. **Code - Парсинг результатов fullbody** - Извлечение и структурирование результатов

### Шаг 31-34: Выбор лучшего изображения и суммирование

31. **Merge** - Объединение результатов анализа selfie и fullbody
32. **Code - Выбор лучшего изображения** - Логика выбора на основе качества и пригодности
33. **Code - Суммирование результатов** - Объединение всех параметров анализа
34. **Code - Выбор типа фигуры** - Определение финального `body_silhouette`

### Шаг 35-36: Обновление сессии и отправка webhook

35. **Supabase - Обновление сессии с результатами** - Update с параметрами анализа
36. **Code - Формирование webhook ссылки** - Создание `result_link` с параметрами
37. **HTTP Request - Webhook callback в React** - POST запрос в `/api/webhook/callback`

## Ключевые изменения в промптах (GPT-4.0 Latest)

### Разделение анализа: Лицо vs Тело

**Selfie (лицо) анализирует:**

- Качество изображения лица (face_visible, face_quality_score, suitable_for_analysis)
- Параметры, определяемые по лицу:
  - color_temperature (на основе тона кожи лица)
  - color_season (один из 12, на основе кожи, волос, глаз)
  - contrast_level (контраст между кожей, волосами, глазами)
  - face_shape (форма лица)
  - hair_color (цвет волос)
  - archetype (архетип по выражению лица, мимике, стилю)
- **НЕ определяет** body_silhouette (тело не видно)

**Fullbody (тело) анализирует:**

- Качество изображения тела (body_visible, body_quality_score, suitable_for_analysis)
- Параметры, определяемые по телу:
  - body_silhouette (силуэт тела: V, A, H, X, O, I)
  - Может дополнить анализ color_season (если лицо плохо видно)
- **Приоритет**: Если качество тела плохое, использовать только силуэт (если видно)

### Промпт для selfie (Шаг 27) - Анализ лица

**Фокус анализа:**

- Только лицо (кожа, волосы, глаза, форма лица, мимика)
- Качество: face_visible, face_quality_score (0-100), suitable_for_analysis
- Если quality_score < 50 или face_visible = false → suitable_for_analysis = false

**Определяемые параметры:**

- color_temperature: на основе тона кожи лица (warm/cool/neutral)
- color_season: один из 12, на основе комбинации кожи + волос + глаз
- contrast_level: контраст между кожей, волосами, глазами
- face_shape: форма лица (7 вариантов)
- hair_color: цвет волос (11 вариантов)
- archetype: архетип по выражению лица и стилю (6 вариантов)

### Промпт для fullbody (Шаг 29) - Анализ тела

**Фокус анализа:**

- Тело и пропорции (силуэт, пропорции плеч/талии/бедер)
- Качество: body_visible, body_quality_score (0-100), suitable_for_analysis
- Если quality_score < 50 или body_visible = false → suitable_for_analysis = false

**Определяемые параметры:**

- body_silhouette: силуэт тела (V, A, H, X, O, I) - ОСНОВНОЙ параметр
- Может дополнить color_season, если лицо плохо видно в selfie

### Исключение результатов при плохом качестве

**Логика исключения:**

1. Если selfie: quality_score < 50 ИЛИ face_visible = false → suitable_for_analysis = false
2. Если fullbody: quality_score < 50 ИЛИ body_visible = false → suitable_for_analysis = false
3. В ноде "Выбор лучшего изображения" (шаг 32):

   - Использовать только изображения с suitable_for_analysis = true
   - Если оба изображения плохого качества → использовать лучшее, но пометить как "low_quality"
   - Если только одно изображение подходит → использовать его
   - Если ни одно не подходит → вернуть ошибку или использовать дефолтные значения

### 12 цветотипов для промптов

```
bright_winter, cool_winter, deep_winter,
cool_summer, light_summer, soft_summer,
warm_spring, light_spring, bright_spring,
warm_autumn, soft_autumn, deep_autumn
```

### Параметры для анализа

- `color_temperature`: 'cool' | 'warm' | 'neutral'
- `color_season`: один из 12 цветотипов
- `contrast_level`: 'high' | 'medium' | 'low'
- `face_shape`: 'oval' | 'round' | 'square' | 'rectangle' | 'triangle' | 'inverted_triangle' | 'diamond'
- `body_silhouette`: 'V' | 'A' | 'H' | 'X' | 'O' | 'I' (только для fullbody)
- `hair_color`: 'black' | 'dark_brown' | 'brown' | 'light_brown' | 'dark_blonde' | 'ash_blonde' | 'cool_blonde' | 'platinum_blonde' | 'red' | 'copper' | 'grey'
- `archetype`: 'rebel' | 'lover' | 'explorer' | 'creator' | 'ruler' | 'sage'

## Файлы для создания/изменения

1. **`funel_new/n8n/workflow-24-steps.md`** - Основная MD инструкция с детальным описанием всех 24 шагов

   - Детальные инструкции для каждой ноды
   - Точные промпты для OpenAI с 12 цветотипами
   - Примеры конфигурации нод
   - Схема подключения нод

2. **Обновление существующих файлов**:

   - `funel_new/n8n/http-request-nodes.md` - Обновить промпты для нод 23 и 24
   - `funel_new/n8n/25-select-best-image.js` - Убедиться, что логика выбора учитывает все параметры

## Особенности реализации

1. **КРИТИЧНО - Промпты должны быть точными**: 

   - OpenAI должен определять точный цветотип из 12 вариантов (bright_winter, cool_winter, и т.д.)
   - НЕ использовать общие сезоны (winter, spring, summer, autumn)
   - Все параметры должны соответствовать типам из `funel_new/types/result.ts`

2. **Структура ответа OpenAI**:

   - Должна включать анализ качества (quality_score, face_visible, suitable_for_analysis)
   - Должна возвращать плоскую структуру (не вложенные объекты)
   - Все значения должны быть строго из допустимых списков

3. **Логика выбора изображения**: 

   - Приоритет fullbody, если он подходит (так как там есть body_silhouette)
   - Если выбран selfie, body_silhouette берется из fullbody анализа (если доступен)

4. **Валидация параметров**: 

   - Все параметры должны соответствовать типам из `funel_new/types/result.ts`
   - Архетипы: только rebel, lover, explorer, creator, ruler, sage (НЕ Hero, Innocent!)

5. **Обработка ошибок**: 

   - Каждый шаг должен иметь обработку ошибок и логирование
   - Парсинг результатов должен валидировать структуру JSON

## Структура MD файла

```markdown
# n8n Workflow: Обработка изображений и анализ стиля (24 шага)

## Обзор workflow
[Описание общего потока]

## Шаг 1: Webhook - Прием данных
[Детальные инструкции]

## Шаг 2: Code - Парсинг данных
[Код и инструкции]

...

## Шаг 24: HTTP Request - Webhook callback в React
[Финальная отправка]

## Схема подключения нод
[Визуальная схема или описание]

## Переменные окружения
[Список необходимых env переменных]

## Troubleshooting
[Частые проблемы и решения]
```

## Тестирование

- Проверить, что все 12 цветотипов корректно определяются GPT-4.0
- Проверить, что body_silhouette определяется только из fullbody
- Проверить валидацию параметров (все значения из допустимых списков)
- Проверить парсинг JSON ответов от GPT-4.0
- Проверить формирование result_link с правильными параметрами
- Проверить отправку webhook в React
- Проверить обработку ошибок при невалидных ответах от GPT-4.0

## Важные замечания по GPT-4.0 Latest

1. **JSON Mode**: Включить в настройках ноды OpenAI (response_format: "json_object")
2. **Max Tokens**: Установить 1000 для анализа изображений
3. **Temperature**: Рекомендуется 0.3-0.5 для более детерминированных результатов
4. **Промпт должен начинаться с инструкции возвращать JSON**: "Return the result as a valid JSON object:"
5. **Четкие списки значений**: Все допустимые значения должны быть явно перечислены в промпте
6. **Примеры не нужны**: GPT-4.0 хорошо понимает структуру без примеров, но списки значений обязательны